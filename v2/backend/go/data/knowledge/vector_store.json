{
  "ddl_1745136750554975400": {
    "id": "ddl_1745136750554975400",
    "type": "ddl",
    "content": "// backend/go/internal/api/routes.go\npackage api\n\nimport (\n\t\"database/sql\"\n\t\"encoding/csv\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sage-ai-v2/internal/api/middleware\"\n\t\"sage-ai-v2/internal/knowledge\"\n\t\"sage-ai-v2/internal/orchestrator\"\n\t\"sage-ai-v2/pkg/logger\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n)\n\n// SetupRoutes configures the API routes\nfunc SetupRoutes(db *sql.DB, orch *orchestrator.Orchestrator) *mux.Router {\n    // Create router\n    router := mux.NewRouter()\n    \n    // Apply middleware\n    router.Use(middleware.LoggingMiddleware)\n    router.Use(middleware.CORSMiddleware)\n    \n    // Extract knowledge manager from orchestrator\n    km := orch.KnowledgeManager\n\n    // Create uploads directory if it doesn't exist\n    os.MkdirAll(\"data/uploads\", 0755)\n\n    // API routes\n    router.HandleFunc(\"/api/query\", func(w http.ResponseWriter, r *http.Request) {\n        handleQueryRequest(w, r, orch)\n    }).Methods(\"POST\", \"OPTIONS\")\n\n    router.HandleFunc(\"/api/upload\", func(w http.ResponseWriter, r *http.Request) {\n        handleFileUpload(w, r)\n    }).Methods(\"POST\", \"OPTIONS\")\n\n    // Training Data API endpoints - IMPORTANT FIX\n    router.HandleFunc(\"/api/training/list\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        dataType := r.URL.Query().Get(\"type\")\n        items, err := km.ListTrainingData(r.Context(), dataType)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(items)\n    }).Methods(\"GET\", \"OPTIONS\")\n    \n    router.HandleFunc(\"/api/training/upload\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        err := r.ParseMultipartForm(32 \u003c\u003c 20)\n        if err != nil {\n            http.Error(w, \"Could not parse form\", http.StatusBadRequest)\n            return\n        }\n        \n        file, handler, err := r.FormFile(\"file\")\n        if err != nil {\n            http.Error(w, \"No file provided\", http.StatusBadRequest)\n            return\n        }\n        defer file.Close()\n        \n        content, err := io.ReadAll(file)\n        if err != nil {\n            http.Error(w, \"Failed to read file\", http.StatusInternalServerError)\n            return\n        }\n        \n        localPath, err := km.StoreFile(handler.Filename, content)\n        if err != nil {\n            http.Error(w, \"Failed to store file\", http.StatusInternalServerError)\n            return\n        }\n        \n        dataType := r.FormValue(\"type\")\n        if dataType == \"\" {\n            dataType = \"ddl\"\n        }\n        \n        description := r.FormValue(\"description\")\n        if description == \"\" {\n            description = handler.Filename\n        }\n        \n        id := fmt.Sprintf(\"%s_%d\", dataType, time.Now().UnixNano())\n        ctx := r.Context()\n        \n        switch dataType {\n        case \"ddl\":\n            err = km.AddDDLSchema(ctx, handler.Filename, string(content), description)\n        case \"documentation\":\n            err = km.AddDocumentation(ctx, description, string(content), []string{})\n        case \"question_sql_json\":\n            pairs, err := km.LoadQuestionSQLPairsFromJSON(ctx, localPath)\n            if err != nil {\n                http.Error(w, fmt.Sprintf(\"Failed to load JSON: %v\", err), http.StatusInternalServerError)\n                return\n            }\n            \n            w.Header().Set(\"Content-Type\", \"application/json\")\n            json.NewEncoder(w).Encode(map[string]interface{}{\n                \"success\": true,\n                \"count\":   pairs,\n                \"path\":    localPath,\n                \"id\":      id,\n            })\n            return\n        case \"auto\":\n            if strings.HasSuffix(handler.Filename, \".sql\") {\n                err = km.AddDDLSchema(ctx, handler.Filename, string(content), description)\n            } else if strings.HasSuffix(handler.Filename, \".json\") {\n                pairs, err := km.LoadQuestionSQLPairsFromJSON(ctx, localPath)\n                if err != nil {\n                    http.Error(w, fmt.Sprintf(\"Failed to load JSON: %v\", err), http.StatusInternalServerError)\n                    return\n                }\n                \n                w.Header().Set(\"Content-Type\", \"application/json\")\n                json.NewEncoder(w).Encode(map[string]interface{}{\n                    \"success\": true,\n                    \"count\":   pairs,\n                    \"path\":    localPath,\n                    \"id\":      id,\n                })\n                return\n            } else {\n                err = km.AddDocumentation(ctx, description, string(content), []string{})\n            }\n        default:\n            http.Error(w, \"Invalid data type\", http.StatusBadRequest)\n            return\n        }\n        \n        if err != nil {\n            http.Error(w, fmt.Sprintf(\"Failed to add training data: %v\", err), http.StatusInternalServerError)\n            return\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(map[string]interface{}{\n            \"success\": true,\n            \"type\":    dataType,\n            \"path\":    localPath,\n            \"id\":      id,\n        })\n    }).Methods(\"POST\", \"OPTIONS\")\n    \n    router.HandleFunc(\"/api/training/add\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        var data struct {\n            Type        string                 `json:\"type\"`\n            Content     string                 `json:\"content\"`\n            Description string                 `json:\"description\"`\n            Metadata    map[string]interface{} `json:\"metadata\"`\n        }\n        \n        if err := json.NewDecoder(r.Body).Decode(\u0026data); err != nil {\n            http.Error(w, \"Invalid request body\", http.StatusBadRequest)\n            return\n        }\n        \n        id := fmt.Sprintf(\"%s_%d\", data.Type, time.Now().UnixNano())\n        ctx := r.Context()\n        var err error\n        \n        switch data.Type {\n        case \"ddl\":\n            err = km.AddDDLSchema(ctx, data.Description, data.Content, data.Description)\n        case \"documentation\":\n            tags := []string{}\n            if tagsData, ok := data.Metadata[\"tags\"].([]interface{}); ok {\n                for _, tag := range tagsData {\n                    if tagStr, ok := tag.(string); ok {\n                        tags = append(tags, tagStr)\n                    }\n                }\n            }\n            err = km.AddDocumentation(ctx, data.Description, data.Content, tags)\n        case \"question_sql\":\n            pair := knowledge.QuestionSQLPair{\n                Question:    data.Content,\n                SQL:         \"\",\n                Description: data.Description,\n                DateAdded:   time.Now().Format(time.RFC3339),\n                Verified:    true,\n            }\n            \n            if sqlData, ok := data.Metadata[\"sql\"].(string); ok {\n                pair.SQL = sqlData\n            }\n            \n            if tagsData, ok := data.Metadata[\"tags\"].([]interface{}); ok {\n                for _, tag := range tagsData {\n                    if tagStr, ok := tag.(string); ok {\n                        pair.Tags = append(pair.Tags, tagStr)\n                    }\n                }\n            }\n            \n            err = km.AddQuestionSQLPair(ctx, pair)\n        default:\n            http.Error(w, \"Invalid data type\", http.StatusBadRequest)\n            return\n        }\n        \n        if err != nil {\n            http.Error(w, fmt.Sprintf(\"Failed to add training data: %v\", err), http.StatusInternalServerError)\n            return\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(map[string]interface{}{\n            \"success\": true,\n            \"type\":    data.Type,\n            \"id\":      id,\n        })\n    }).Methods(\"POST\", \"OPTIONS\")\n    \n    router.HandleFunc(\"/api/training/view/{id}\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        vars := mux.Vars(r)\n        id := vars[\"id\"]\n        \n        if id == \"\" {\n            http.Error(w, \"ID is required\", http.StatusBadRequest)\n            return\n        }\n        \n        item, err := km.GetTrainingItem(r.Context(), id)\n        if err != nil {\n            logger.ErrorLogger.Printf(\"Failed to get training item: %v\", err)\n            http.Error(w, fmt.Sprintf(\"Failed to get training item: %v\", err), http.StatusInternalServerError)\n            return\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(item)\n    }).Methods(\"GET\", \"OPTIONS\")\n    \n    router.HandleFunc(\"/api/training/delete/{id}\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"DELETE, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        vars := mux.Vars(r)\n        id := vars[\"id\"]\n        \n        if id == \"\" {\n            http.Error(w, \"ID is required\", http.StatusBadRequest)\n            return\n        }\n        \n        err := km.DeleteTrainingItem(r.Context(), id)\n        if err != nil {\n            logger.ErrorLogger.Printf(\"Failed to delete training item: %v\", err)\n            http.Error(w, fmt.Sprintf(\"Failed to delete training item: %v\", err), http.StatusInternalServerError)\n            return\n        }\n        \n        w.WriteHeader(http.StatusNoContent)\n    }).Methods(\"DELETE\", \"OPTIONS\")\n    \n    // Chat History API\n    SetupChatRoutes(router, km)\n\n    // Auth routes\n    router.HandleFunc(\"/api/auth/signin\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        var req struct {\n            Email    string `json:\"email\"`\n            Password string `json:\"password\"`\n        }\n        \n        if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n            http.Error(w, \"Invalid request body\", http.StatusBadRequest)\n            return\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(map[string]interface{}{\n            \"user\": map[string]interface{}{\n                \"id\": \"user123\",\n                \"email\": req.Email,\n                \"name\": \"Test User\",\n                \"createdAt\": time.Now(),\n                \"lastLoginAt\": time.Now(),\n            },\n            \"accessToken\": \"mock_token_\" + req.Email,\n        })\n    }).Methods(\"POST\", \"OPTIONS\")\n    \n    router.HandleFunc(\"/api/auth/signup\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        var req struct {\n            Email    string `json:\"email\"`\n            Password string `json:\"password\"`\n            Name     string `json:\"name\"`\n        }\n        \n        if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n            http.Error(w, \"Invalid request body\", http.StatusBadRequest)\n            return\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(map[string]interface{}{\n            \"user\": map[string]interface{}{\n                \"id\": \"user123\",\n                \"email\": req.Email,\n                \"name\": req.Name,\n                \"createdAt\": time.Now(),\n                \"lastLoginAt\": time.Now(),\n            },\n            \"accessToken\": \"mock_token_\" + req.Email,\n        })\n    }).Methods(\"POST\", \"OPTIONS\")\n    \n    router.HandleFunc(\"/api/auth/signout\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(map[string]bool{\n            \"success\": true,\n        })\n    }).Methods(\"POST\", \"OPTIONS\")\n    \n    // OAuth URL endpoint - CRITICAL FIX\n    router.HandleFunc(\"/api/auth/oauth/url/{provider}\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        vars := mux.Vars(r)\n        provider := vars[\"provider\"]\n        \n        redirectURI := r.URL.Query().Get(\"redirect_uri\")\n        if redirectURI == \"\" {\n            http.Error(w, \"Missing redirect_uri parameter\", http.StatusBadRequest)\n            return\n        }\n        \n        logger.InfoLogger.Printf(\"OAuth URL request for provider: %s with redirect URI: %s\", provider, redirectURI)\n        \n        var oauthURL string\n        \n        switch provider {\n        case \"github\":\n            oauthURL = fmt.Sprintf(\"https://github.com/login/oauth/authorize?client_id=Ov23liJMbcmt6eXGI7yN\u0026redirect_uri=%s\u0026scope=read:user,user:email\", \n                url.QueryEscape(redirectURI))\n        case \"google\":\n            oauthURL = fmt.Sprintf(\"https://accounts.google.com/o/oauth2/auth?client_id=64583008448-4aa9mivl1jurlp1bheabkc5m0irc6fsp.apps.googleusercontent.com\u0026redirect_uri=%s\u0026response_type=code\u0026scope=email+profile\", \n                url.QueryEscape(redirectURI))\n        default:\n            http.Error(w, \"Invalid provider\", http.StatusBadRequest)\n            return\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(map[string]string{\n            \"url\": oauthURL,\n        })\n    }).Methods(\"GET\", \"OPTIONS\")\n    \n    // OAuth sign-in endpoint - CRITICAL FIX\n    router.HandleFunc(\"/api/auth/oauth/{provider}\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        vars := mux.Vars(r)\n        provider := vars[\"provider\"]\n        \n        var req struct {\n            Code        string `json:\"code\"`\n            RedirectURI string `json:\"redirect_uri\"`\n        }\n        \n        if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n            logger.ErrorLogger.Printf(\"Failed to parse OAuth request: %v\", err)\n            http.Error(w, \"Invalid request format\", http.StatusBadRequest)\n            return\n        }\n        \n        var name, email string\n        switch provider {\n        case \"github\":\n            name = \"GitHub User\"\n            email = \"user@github.example.com\"\n        case \"google\":\n            name = \"Google User\"\n            email = \"user@google.example.com\"\n        default:\n            name = \"OAuth User\"\n            email = \"user@example.com\"\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(map[string]interface{}{\n            \"user\": map[string]interface{}{\n                \"id\": fmt.Sprintf(\"%s_user_123\", provider),\n                \"name\": name,\n                \"email\": email,\n                \"createdAt\": time.Now(),\n                \"lastLoginAt\": time.Now(),\n            },\n            \"accessToken\": \"mock_oauth_token_\" + provider,\n        })\n    }).Methods(\"POST\", \"OPTIONS\")\n    \n    router.HandleFunc(\"/api/auth/user\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        json.NewEncoder(w).Encode(map[string]interface{}{\n            \"id\": \"user123\",\n            \"name\": \"Test User\",\n            \"email\": \"user@example.com\",\n            \"createdAt\": time.Now(),\n            \"lastLoginAt\": time.Now(),\n        })\n    }).Methods(\"GET\", \"OPTIONS\")\n    \n    // Global handler for OPTIONS requests\n    router.PathPrefix(\"/\").Methods(\"OPTIONS\").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization, X-Requested-With\")\n        w.Header().Set(\"Access-Control-Max-Age\", \"3600\")\n        w.WriteHeader(http.StatusOK)\n    })\n    \n    // Health check endpoint\n    router.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Content-Type\", \"text/plain\")\n        w.WriteHeader(http.StatusOK)\n        w.Write([]byte(\"OK\"))\n    }).Methods(\"GET\")\n    \n    return router\n}\n\n// handleQueryRequest processes the query against a CSV file\nfunc handleQueryRequest(w http.ResponseWriter, r *http.Request, orch *orchestrator.Orchestrator) {\n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\")\n    w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n    \n    if r.Method == \"OPTIONS\" {\n        w.WriteHeader(http.StatusOK)\n        return\n    }\n    \n    var req struct {\n        Query            string                 `json:\"query\"`\n        CSVPath          string                 `json:\"csvPath\"`\n        UseKnowledgeBase bool                   `json:\"useKnowledgeBase\"`\n        TrainingDataIDs  []string               `json:\"trainingDataIds\"`\n        Options          map[string]interface{} `json:\"options\"`\n    }\n\n    if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n        http.Error(w, \"Invalid request body\", http.StatusBadRequest)\n        return\n    }\n\n    if req.Options == nil {\n        req.Options = make(map[string]interface{})\n    }\n    \n    req.Options[\"useKnowledgeBase\"] = req.UseKnowledgeBase\n    if len(req.TrainingDataIDs) \u003e 0 {\n        req.Options[\"trainingDataIds\"] = req.TrainingDataIDs\n    }\n    \n    result, err := orch.ProcessQueryWithOptions(r.Context(), req.Query, req.CSVPath, req.Options)\n    if err != nil {\n        http.Error(w, fmt.Sprintf(\"Error processing query: %v\", err), http.StatusInternalServerError)\n        return\n    }\n\n    response := map[string]interface{}{\n        \"query\":  req.Query,\n        \"sql\":    result.GeneratedQuery,\n        \"results\": result.ExecutionResult,\n        \"knowledgeContext\": nil,\n    }\n    \n    if result.Analysis != nil {\n        if resp, ok := result.Analysis[\"response\"].(string); ok {\n            response[\"response\"] = resp\n        }\n    }\n    \n    if result.KnowledgeContext != nil {\n        knowledgeContext := []map[string]interface{}{}\n        \n        for _, ddl := range result.KnowledgeContext.DDLSchemas {\n            knowledgeContext = append(knowledgeContext, map[string]interface{}{\n                \"type\":        \"ddl\",\n                \"id\":          ddl.ID,\n                \"description\": ddl.Description,\n                \"content\":     ddl.Content,\n            })\n        }\n        \n        for _, doc := range result.KnowledgeContext.Documentation {\n            knowledgeContext = append(knowledgeContext, map[string]interface{}{\n                \"type\":        \"documentation\",\n                \"id\":          doc.ID,\n                \"description\": doc.Description,\n                \"content\":     doc.Content,\n            })\n        }\n        \n        for _, pair := range result.KnowledgeContext.QuestionSQLPairs {\n            knowledgeContext = append(knowledgeContext, map[string]interface{}{\n                \"type\":        \"question_sql\",\n                \"id\":          pair.Description,\n                \"description\": pair.Description,\n                \"question\":    pair.Question,\n                \"sql\":         pair.SQL,\n            })\n        }\n        \n        response[\"knowledgeContext\"] = knowledgeContext\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(response)\n}\n\n// handleFileUpload processes file uploads for CSV data\nfunc handleFileUpload(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\")\n    w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n    \n    if r.Method == \"OPTIONS\" {\n        w.WriteHeader(http.StatusOK)\n        return\n    }\n    \n    err := r.ParseMultipartForm(32 \u003c\u003c 20)\n    if err != nil {\n        http.Error(w, \"Could not parse form\", http.StatusBadRequest)\n        return\n    }\n\n    file, handler, err := r.FormFile(\"file\")\n    if err != nil {\n        http.Error(w, \"No file provided\", http.StatusBadRequest)\n        return\n    }\n    defer file.Close()\n\n    timestamp := time.Now().UnixNano()\n    filename := fmt.Sprintf(\"%d_%s\", timestamp, handler.Filename)\n    filepath := filepath.Join(\"data\", \"uploads\", filename)\n\n    dst, err := os.Create(filepath)\n    if err != nil {\n        http.Error(w, \"Failed to create file\", http.StatusInternalServerError)\n        return\n    }\n    defer dst.Close()\n\n    if _, err := io.Copy(dst, file); err != nil {\n        http.Error(w, \"Failed to save file\", http.StatusInternalServerError)\n        return\n    }\n\n    headers, err := extractCSVHeaders(filepath)\n    if err != nil {\n        logger.ErrorLogger.Printf(\"Error extracting CSV headers: %v\", err)\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(map[string]interface{}{\n        \"success\":   true,\n        \"filename\":  handler.Filename,\n        \"filePath\":  filepath,\n        \"timestamp\": timestamp,\n        \"headers\":   headers,\n    })\n}\n\n// extractCSVHeaders reads the first row of a CSV file to get the column headers\nfunc extractCSVHeaders(filePath string) ([]string, error) {\n    file, err := os.Open(filePath)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open file: %w\", err)\n    }\n    defer file.Close()\n    \n    reader := csv.NewReader(file)\n    headers, err := reader.Read()\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read CSV headers: %w\", err)\n    }\n    \n    return headers, nil\n}",
    "metadata": {
      "name": "QQ"
    },
    "embedding": [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0.0006465169,
      0.027961856,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0.29000324,
      0.00105059,
      0.029739777,
      0,
      0,
      0.0009697753,
      0.00040407304,
      0.000040407307,
      0.014627445,
      0.014627445,
      0.0014142557,
      0.00016162923,
      0.01454663,
      0.006990464,
      0.020728948,
      0.0050509134,
      0.00036366575,
      0.00024244383,
      0.00056570227,
      0.00048488766,
      0.00016162923,
      0.00016162923,
      0.00016162923,
      0.000080814614,
      0.000121221914,
      0.000080814614,
      0.0072329077,
      0.00048488766,
      0.00016162923,
      0.006384354,
      0.000040407307,
      0.000080814614,
      0.00016162923,
      0.005414579,
      0.0010101827,
      0.0051721353,
      0.0023436237,
      0.004242767,
      0.0022224018,
      0.0007273315,
      0.004485211,
      0.0037982867,
      0.00024244383,
      0.0010101827,
      0.0015354776,
      0.002262809,
      0.0035962502,
      0.0061823176,
      0.0037982867,
      0.0010909972,
      0.0033538064,
      0.008970422,
      0.0053337645,
      0.0012526264,
      0.0006869242,
      0.001454663,
      0.00020203652,
      0,
      0,
      0.0017375142,
      0,
      0.0017375142,
      0,
      0.0012122191,
      0.0012930338,
      0.031073218,
      0.0008081461,
      0.0150315175,
      0.020971391,
      0.06238888,
      0.008041054,
      0.008364312,
      0.010990787,
      0.028689187,
      0.0021415872,
      0.002262809,
      0.018627768,
      0.0075157587,
      0.03196218,
      0.032285437,
      0.0160417,
      0.0036366575,
      0.050347503,
      0.027396154,
      0.053580087,
      0.01499111,
      0.0029497333,
      0.010142234,
      0.0023032164,
      0.0034750283,
      0.00060610956,
      0.005535801,
      0,
      0.005535801,
      0,
      0
    ],
    "date_added": "2025-04-20T04:12:30-04:00",
    "description": "QQ"
  }
}